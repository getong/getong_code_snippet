* renegade code reading

** openraft raft start

#+begin_src rust
/// A client interface to the raft
#[derive(Clone)]
pub struct RaftClient {
    /// The client's config
    pub(crate) config: RaftClientConfig,
    /// The inner raft
    raft: Raft,
    /// The network to use for the raft client
    network_factory: P2PNetworkFactoryWrapper,
    /// A lock to prevent simultaneous membership changes
    membership_change_lock: Arc<Mutex<()>>,
}

impl RaftClient {
  /// Create a new raft client
  pub async fn new<N: P2PNetworkFactory>(
    config: RaftClientConfig,
    db: Arc<DB>,
    net_factory: N,
    state_machine: StateMachine,
  ) -> Result<Self, ReplicationV2Error> {
    let raft_config = Arc::new(RaftConfig {
      cluster_name: config.cluster_name.clone(),
      heartbeat_interval: config.heartbeat_interval,
      election_timeout_min: config.election_timeout_min,
      election_timeout_max: config.election_timeout_max,
      snapshot_max_chunk_size: config.snapshot_max_chunk_size,
      install_snapshot_timeout: config.install_snapshot_timeout,
      max_payload_entries: config.max_payload_entries,
      ..Default::default()
    });

    // Create the raft
    let p2p_factory = P2PNetworkFactoryWrapper::new(net_factory);
    let log_store = LogStore::new(db.clone());
    let raft = Raft::new(config.id, raft_config, p2p_factory.clone(), log_store, state_machine)
      .await
      .map_err(err_str!(ReplicationV2Error::RaftSetup))?;

    // Initialize the raft
    if config.init {
      let initial_nodes = config.initial_nodes.clone();
      let members = initial_nodes.into_iter().collect::<BTreeMap<_, _>>();
      raft.initialize(members).await.map_err(err_str!(ReplicationV2Error::RaftSetup))?;
    }

    Ok(Self {
      config,
      raft,
      network_factory: p2p_factory,
      membership_change_lock: Arc::new(Mutex::new(())),
    })
  }
}
#+end_src

** P2PNetworkFactory definition

#+begin_src rust
pub trait P2PNetworkFactory: Send + Sync + 'static {
  /// Create a new p2p client
  fn new_p2p_client(&self, target: NodeId, target_info: Node) -> P2PRaftNetworkWrapper;
}

/// A wrapper around the p2p raft network that allows for a default
/// `RaftNetwork` implementation and to hide generics from higher level
/// interfaces
pub struct P2PRaftNetworkWrapper {
  /// The inner p2p network
  inner: Box<dyn P2PRaftNetwork + Send + Sync>,
}

/// A generalization of the raft network trait that specifically allows for
/// point-to-point communication
///
/// We implement the general raft network trait for all types that fit this
/// signature by simply calling out to the p2p implementation
#[async_trait]
pub trait P2PRaftNetwork: 'static + Sync + Send {
  /// The target this client is sending requests to
  fn target(&self) -> NodeId;
  /// Send an request to the target node
  async fn send_request(
    &self,
    target: NodeId,
    request: RaftRequest,
  ) -> Result<RaftResponse, RPCError<NodeId, Node, RaftError<NodeId>>>;
}

/// The request type a raft node may send to another
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum RaftRequest {
  /// A request to append entries
  AppendEntries(AppendEntriesRequest<TypeConfig>),
  /// A request to install a snapshot
  InstallSnapshot(InstallSnapshotRequest<TypeConfig>),
  /// A request to vote
  Vote(VoteRequest<NodeId>),
  /// A proposal forwarded to the leader
  ForwardedProposal(Proposal),
}

/// The response type a raft node may send to another
#[derive(Debug, Serialize, Deserialize)]
pub enum RaftResponse {
  /// A simple ack when no data must be returned
  Ack,
  /// A response to an append entries request
  AppendEntries(AppendEntriesResponse<NodeId>),
  /// A response to an install snapshot request
  InstallSnapshot(Result<InstallSnapshotResponse<NodeId>, InstallSnapshotError>),
  /// A response to a vote request
  Vote(VoteResponse<NodeId>),
}
#+end_src