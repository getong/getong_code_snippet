* erlang unicode
:PROPERTIES:
:CUSTOM_ID: erlang-unicode
:END:
** erlang reference
:PROPERTIES:
:CUSTOM_ID: erlang-reference
:END:
Reference to [[http://wudaijun.com/2016/12/unicode-in-erlang/][Erlang
Unicodeç¼–ç ]]

#+begin_quote
ASCII: ä¸ç”¨å¤šè¯´ï¼Œç¼–ç ç©ºé—´ä¸º7ä½(0-127) ISO 8859-1:
åˆç§°Latin-1ï¼Œä»¥ASCIIä¸ºåŸºç¡€ï¼Œåœ¨ç©ºç½®çš„0xA0-0xFFçš„èŒƒå›´å†…ï¼ŒåŠ å…¥96ä¸ªå­—æ¯åŠç¬¦å·ã€‚ç¼–ç ç©ºé—´ä¸º8ä½(0-255)
UCS-2: 16ä½ç¼–ç ç©ºé—´ åˆç§°åŸºæœ¬å¤šæ–‡ç§å¹³é¢æˆ–é›¶å¹³é¢ UCS-4: 32ä½ç¼–ç ç©ºé—´
åœ¨UCS-2åŸºæœ¬ä¸Šï¼ŒåŠ å…¥è¾…åŠ©å¹³é¢(ç›®å‰æœ‰16ä¸ªè¾…åŠ©å¹³é¢ï¼Œè‡³å°‘éœ€è¦21ä½) æ³¨1:
UCS(Universal Character Set, é€šç”¨å­—ç¬¦é›†) æ³¨2:
ä»¥ä¸Šå››ç§ç¼–ç éƒ½æ˜¯å‘å‰å…¼å®¹çš„ï¼Œé€šå¸¸æˆ‘ä»¬æ‰€è¯´çš„Unicodeç¼–ç æŒ‡UCS-2å’ŒUCS-4ï¼Œç›®å‰å¹¿æ³›è¿ç”¨çš„æ˜¯UCS-2

#+end_quote

code:

#+begin_src erlang
1> L = "ä¸­æ–‡".
...
4> UTF8 = unicode:characters_to_binary(L).% å°†Lä¸­çš„unicodeç¼–ç è½¬æ¢ä¸ºUTF8 binary
<228,184,173,230,150,135>>
5> UTF16Big = unicode:characters_to_binary(UTF8,utf8,utf16).
<<78,45,101,135>> % é»˜è®¤ä¸ºBig Endian
6> UTF16Little = unicode:characters_to_binary(UTF8,utf8,{utf16,little}).
<<45,78,135,101>>

% æ–¹æ¡ˆä¸‰. åˆ©ç”¨binaryæ„é€ è¯­æ³•æ„å»º
7> UTF8 = <<"ä¸­æ–‡"/utf8>>.
<<228,184,173,230,150,135>>

...
13> io:format("~ts", [UTF8]).
ä¸­æ–‡ok
#+end_src

#+begin_quote
iolist:
0-255ç¼–ç (Latin-1)çš„listsï¼Œbinaryï¼Œæˆ–å®ƒä»¬çš„åµŒå¥—ï¼Œå¦‚[["123",<<"456">>],<<"789">>]
unicode binary: UTF8ç¼–ç çš„binary(Erlangé»˜è®¤ä½¿ç”¨UTF8 binaryç¼–ç unicode)
charlist: UTF8ç¼–ç çš„binaryï¼Œæˆ–åŒ…å«æœ‰æ•ˆunicode
codepointçš„listsï¼Œæˆ–å®ƒä»¬çš„åµŒå¥—ï¼Œå¦‚[<<"hello">>, "ä¸­å›½"]

#+end_quote

#+begin_quote
~såªèƒ½æ‰“å°iolistï¼Œbinaryï¼Œæˆ–atomï¼Œå› æ­¤ä¸èƒ½ç›´æ¥æ‰“å°ä¸­æ–‡lists(æ— æ³•è§£ç è¶…è¿‡255çš„codepoint)æˆ–UTF8
binary(ä¼šæŒ‰å­—èŠ‚è§£é‡Šï¼Œå‡ºç°ä¹±ç )ã€‚

#+end_quote

#+begin_quote
~tsåˆ™å¯æ‰“å°charlistå’Œunicode binaryã€‚

#+end_quote

#+begin_quote
~på¦‚æœä¸èƒ½æ‰“å°å‡ºASCII(0-127)å­—ç¬¦ï¼Œåˆ™ç›´æ¥æ‰“å°å‡ºåŸç”ŸTermï¼Œä¸ä¼šå¯¹Unicodeç¼–ç è¿›è¡Œå¤„ç†ã€‚

#+end_quote

** convert http post data to unicode
:PROPERTIES:
:CUSTOM_ID: convert-http-post-data-to-unicode
:END:
#+begin_src erlang
utf8_list_to_string(StrangeList) ->
  unicode:characters_to_list(list_to_binary(StrangeList)).
#+end_src

[[http://erlang.org/doc/apps/stdlib/unicode_usage.html][Using Unicode in
Erlang]]
[[https://stackoverflow.com/questions/21304233/how-to-support-chinese-in-http-request-body-erlang][how
to support chinese in http request body? erlang]]

** erlang file encode
:PROPERTIES:
:CUSTOM_ID: erlang-file-encode
:END:
#+begin_src erlang
%% coding: latin-1
#+end_src

The default is UTF-8, but this can make it use local encode.

** jsx encode utf8 words
:PROPERTIES:
:CUSTOM_ID: jsx-encode-utf8-words
:END:
#+begin_src erlang
UTF8Words = [{<<"word">>, unicode:characters_to_binary("ä¸­æ–‡")}]ï¼Œ
jsx:encode(UTF8Words)
#+end_src

jsx only support list, if the element of the list is tuple, change the
tuple element to list.

** unicode regxp pattern match
:PROPERTIES:
:CUSTOM_ID: unicode-regxp-pattern-match
:END:
#+begin_src erlang
1> re:run("hello ä¸­å›½ ren", "[\x{4e00}-\x{9fff}]+", [unicode]).
2> {ok, RegUni} = re:compile("\\p{L}{5}", [unicode]).
 {ok,{re_pattern,0,1,0,
                 <<69,82,67,80,77,0,0,0,0,8,0,0,1,0,0,0,255,255,255,255,
                   255,255,...>>}}
3> re:run(<<"ã“ã‚“ã«ã¡ã¯"/utf8>>, RegUni).
#+end_src

copy from [Erlang 0062] Erlang Unicode
ä¸¤ä¸‰äº‹](https://www.cnblogs.com/me-sa/archive/2012/05/31/erlang-unicode.html)
[[http://erlang.org/pipermail/erlang-questions/2016-December/091115.html][erlang-questions
Regexp Matching on Unicode]]

** jsx decode result is map type in v3.0
:PROPERTIES:
:CUSTOM_ID: jsx-decode-result-is-map-type-in-v3.0
:END:
But the prior version is a list.

** unicode
:PROPERTIES:
:CUSTOM_ID: unicode
:END:

#+begin_quote

#+begin_quote

#+begin_quote
<<"abcdef">> as a binary string, which is shorthand for <<$a, $b, $c,
$d, $e, $f>>. This is an old standard list of Latin1 integers
transformed as a binary. By default this literal format does not support
Unicode encodings, and if you put a value that is too large in there
(such as 16#1f914) by declaring a binary like <<"ğŸ¤”">> in your source
file, you will instead find yourself with an overflow, and the final
binary <<20>>. This is implemented with an Erlang binary (what is
essentially an immutable byte array), and is meant to handle any kind of
binary data content, even if it's not text. <<"abcdef"/utf8>> as a
binary Unicode string that is encoded as UTF-8. This one would work to
support emojis. It is still implemented as an Erlang binary, but the
/utf8 constructor ensures proper Unicode encoding. <<"ğŸ¤”"/utf8>> returns
<<240,159,164,148>>, which is the proper sequence to represent the
thinking emoji in UTF-8.

#+end_quote

#+end_quote

#+end_quote

copy from
[[https://adoptingerlang.org/docs/development/hard_to_get_right/][Hard
Things to Get Right]]
