* elixir func
:PROPERTIES:
:CUSTOM_ID: elixir-func
:END:
通常，在单行代码使用do: 在多行代码使用do...end 语法 ## do...end

#+begin_example
%% times.exs
defmodule Times do
    def double(n) do
        n * 2
    end
end
#+end_example

** do:
:PROPERTIES:
:CUSTOM_ID: do
:END:
#+begin_example
defmodule Times do
    def double(n), do: n * 2
end
#+end_example

** inspect a list more then 50 elements
:PROPERTIES:
:CUSTOM_ID: inspect-a-list-more-then-50-elements
:END:
#+begin_src elixir
iex(1)> x = for i <- 1 .. 60, do: i
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
43, 44, 45, 46, 47, 48, 49, 50, ...]
iex(2)> inspect(x)
“[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, ...]”
iex(3)> inspect(x, limit: :infinity)
“[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]”
#+end_src

the list can be generated by Enum.to_list

#+begin_src elixir
x = Enum.to_list( 1 .. 5)
#+end_src

** try ... catch
:PROPERTIES:
:CUSTOM_ID: try-catch
:END:
BEAM distinguishes three types of runtime errors: errors, exits, and
throws.

#+begin_src elixir
try do
  ...
catch error_type, error_value ->
  ...
end
#+end_src

or

#+begin_src elixir
try do
  ...
catch error_type1, error_value1 ->
  ...
catch error_type2, error_value2 ->
  ...
end
#+end_src

** Base
:PROPERTIES:
:CUSTOM_ID: base
:END:
#+begin_src elixir
:crypto.hash(:md5, content) |> Base.encode16
#+end_src

** File and IO
:PROPERTIES:
:CUSTOM_ID: file-and-io
:END:
#+begin_src elixir
{:ok, file} = File.open("a.txt", [:write])
IO.puts(file, "test word")
#+end_src

a test sample for the library Ink:

#+begin_src elixir
config :logger, Ink,
  name: "project_name",
  level: :info,
  io_device: elem(File.open("a.txt", [:write]), 1),
  metadata: [:pid]
#+end_src

** exception
:PROPERTIES:
:CUSTOM_ID: exception
:END:
#+begin_src elixir
def unreliable_method do
  # do something
  :ok
rescue
  err ->
    Logger.error(Exception.format(:error, err, __STACKTRACE__))
    {:error, :processing_failed}
end
#+end_src

copy from
[[https://stackoverflow.com/questions/53589585/elixir-correct-way-of-printing-stacktrace][Elixir:
Correct way of printing *STACKTRACE*]]
