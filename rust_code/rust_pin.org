* rust pin
:PROPERTIES:
:CUSTOM_ID: rust-pin
:END:
[[https://folyd.com/blog/rust-pin-unpin/][Rustçš„Pinä¸Unpin]]
[[https://folyd.com/blog/rust-pin-advanced/][Rust Pin è¿›é˜¶]]
[[https://rustcc.cn/article?id=4479f801-d28d-40cb-906c-85d8a04e8679][å…³äºPin,å¥½ç»•çš„æ¦‚å¿µ]]
[[https://arunanshub.hashnode.dev/self-referential-structs-in-rust][Self
Referential Structs in Rust]] [[https://learnku.com/articles/46094][005
Rust å¼‚æ­¥ç¼–ç¨‹ï¼ŒPin ä»‹ç»(a very basic example, but very helpful)]]
[[http://www.tutzip.com/tut/rust-async-cn/04_pinning/01_chapter.zh.html][Pinning]]
[[https://fasterthanli.me/articles/pin-and-suffering][Pin and
suffering]]
[[https://cloud.tencent.com/developer/article/1628311][Rustä¸­çš„Pinè¯¦è§£]]

** related crate
:PROPERTIES:
:CUSTOM_ID: related-crate
:END:
[[https://crates.io/crates/pin-utils][pin-utils]]
[[https://crates.io/crates/pin-project][pin-project]]

** pin get element as mut
:PROPERTIES:
:CUSTOM_ID: pin-get-element-as-mut
:END:
#+begin_src shell
struct SlowRead<R> {
    //       ğŸ‘‡ now optional!
    reader: Option<R>,
    sleep: Sleep,
}

impl<R> SlowRead<R>
where
    R: Unpin,
{
    // ğŸ‘‡ now takes pinned mutable reference to Self, and returns an option
    fn take_inner(self: Pin<&mut Self>) -> Option<R> {
        self.reader.take()
    }
}
#+end_src

It does not compile.

#+begin_src rust
impl<R> SlowRead<R>
where
    R: Unpin,
{
    // ğŸ‘‡ now takes pinned mutable reference to Self, and returns an option
    fn take_inner(self: Pin<&mut Self>) -> Option<R> {
        unsafe { self.get_unchecked_mut().reader.take() }
    }
}
#+end_src

copy from [[https://fasterthanli.me/articles/pin-and-suffering][Pin and
suffering]]

** rust api doc
:PROPERTIES:
:CUSTOM_ID: rust-api-doc
:END:
| method name                           | meaning                                             |
|---------------------------------------+-----------------------------------------------------|
| new()                                 | pin a Unpin value                                   |
| unsafe new_unchecked()                | pin a !Unpin value                                  |
| as_ref()                              | convert &Pin<P> to Pin<&T>                          |
| as_mut()                              | convert &mut Pin<P> to Pin<&mut T>                  |
| get_ref()                             | convert Pin<P> to &T                                |
| get_mut()                             | convert Pin<P>, T:Unpin to &mut T                   |
| unsafe get_unchecked_mut()            | convert Pin<P>, T:!Unpin to T                       |
| Pin::into_inner(pin)                  | convert Pin<p> to p, t:Unpin                        |
| unsafe Pin::into_inner_unchecked(pin) | convert Pin<p> to p, t: !Unpin                      |
| set(t)                                | set a new value t to the old t                      |
| into_ref()                            | convert Pin<&mut T> to Pin<&T>                      |
| unsafe map_unchecked(func: F)         | Constructs a new pin by mapping the interior value. |
| unsafe map_unchecked_mut(func: F)     | Constructs a new pin by mapping the interior value. |

copy from [[https://folyd.com/blog/rust-pin-advanced/][Rust Pin è¿›é˜¶]]

** mutable pinned
:PROPERTIES:
:CUSTOM_ID: mutable-pinned
:END:
#+begin_src rust
struct SlowRead{
    reader: Option<R>,
}

let self : Pin<&mut SlowRead<R>> = ...
let this = unsafe{self.get_unchecked_mut()};
reader = &mut this.reader;

match reader{
    Some(reader) => {
        let reader = unsafe {Pin::new_unchecked(reader)};
        reader.poll_read(cx, buf)
        }
    None => {}
}
#+end_src

copy from [[https://fasterthanli.me/articles/pin-and-suffering][Pin and suffering]]

** future poll_unpin example

#+begin_src rust
use futures::FutureExt;
use std::{
  future::Future,
  pin::Pin,
  task::{Context, Poll},
};
use tokio::time::Duration;
use tokio::time::Sleep;

#[tokio::main]
async fn main() {
  let fut = MyFuture::new();
  println!("Awaiting fut...");
  fut.await;
  println!("Awaiting fut... done!");
}

struct MyFuture {
  sleep: Pin<Box<Sleep>>,
}

impl MyFuture {
  fn new() -> Self {
    Self {
      sleep: Box::pin(tokio::time::sleep(Duration::from_secs(1))),
    }
  }
}

impl Future for MyFuture {
  type Output = ();

  fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
    println!("MyFuture::poll()");
    // let sleep = Pin::new(&mut self.sleep);
    // let sleep = self.sleep.as_mut();
    // sleep.poll(cx)
    let sleep = &mut self.sleep;
    sleep.poll_unpin(cx)
  }
}
#+end_src

copy from [[https://fasterthanli.me/articles/pin-and-suffering][Pin and suffering]]

and the poll_unpin code definition:

#+begin_src rust
fn poll_unpin(&mut self, cx: &mut Context<'_>) -> Poll<Self::Output>
where
  Self: Unpin,
{
  Pin::new(self).poll(cx)
}
#+end_src

The _poll_unpin_ is still using _poll_ function.

** å¦‚æœä¸Pinä½å®ç°Futureçš„structä¼šæœ‰å¯èƒ½å‘ç”ŸPanic

#+begin_src rust
use futures::Future;
use std::{
    mem::swap,
    pin::Pin,
    task::Poll,
    time::Duration
};
use tokio::{
    macros::support::poll_fn,
    time::sleep
};


async fn main() {
    let mut sleep1 = sleep(Duration::from_secs(1));
    let mut sleep2 = sleep(Duration::from_secs(1));

    {
        let mut sleep1 = unsafe { Pin::new_unchecked(&mut sleep1)};
        poll_fn(|cx| {
            let _ = sleep1.as_mut().poll(cx);
            Poll::Ready(())
        }).await;
    }
    swap(&mut sleep1, &mut sleep2);
    sleep1.await;
    sleep2.await;
}
#+end_src

The code is wrong.

It must be pin in box.
But if you're holding a Box, well, then you're only holding a pointer to a Sleep that lives somewhere
in heap-allocated memory. That somewhere will never change, ie. the Sleep itself will never move.
The pointer to Sleep can be passed around, and everything is fine.

copy from [[https://chaochaogege.com/2021/06/08/54/][Rust-Pinæå‡ºçš„å¿…è¦æ€§-ä»¥åŠæˆ‘å¯¹Pinçš„è®¤è¯†]]
