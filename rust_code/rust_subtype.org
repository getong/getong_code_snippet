* rust subtype
:PROPERTIES:
:CUSTOM_ID: rust-subtype
:END:
** doc reference
:PROPERTIES:
:CUSTOM_ID: doc-reference
:END:
[[https://doc.rust-lang.org/nomicon/subtyping.html][Subtyping and
Variance]]
[[https://doc.rust-lang.org/nomicon/phantom-data.html][PhantomData]]
[[https://zhuanlan.zhihu.com/p/41814387][逆变、协变与子类型，以及Rust]]
[[https://iovxw.net/p/phantomdata-magic/][PhantomData 黑魔法]]
[[https://stackoverflow.com/questions/74266349/subtyping-and-variance-mut-invariant-violate-error-in-rust][Subtyping
and Variance (&mut invariant) violate error in rust]]

** code explaination
:PROPERTIES:
:CUSTOM_ID: code-explaination
:END:
#+begin_src rust
fn main() {
    struct Foo<'a, T> {
        a: &'a mut T,
    }

    let p1 = 1;
    let mut p2 = &p1;
    {
        let p3 = 2;
        let mut p4 = &p3;
        let mut f = Foo {
            a: &mut p4,
        };
        f.a = &mut p2;
        println!("{}", f.a);
    }
    println!("{}", p2);
}
#+end_src

#+begin_quote

#+begin_quote

#+begin_quote
The core of the problem is that f has a single fixed type Foo<'a, &'b
i32> and by the variance rules for mutable references, &'b i32 is
invariant and thus 'b is invariant.

#+end_quote

#+end_quote

#+end_quote

However, f is used with T as two separate lifetimes via p2 and p4. How
does the compiler choose? Well it cannot shorten the lifetime used by p2
into that of p4, because then p2 can be modified to reference something
of a smaller lifetime and thus p2 can dangle at the last println!
(consider what would happen if you added *f.a = &p3; right after
assigning f.a to &mut p2). The only option is for the lifetime used by
p4 to be widened to match p2.

Since p4 must match the lifetime of p2, the assignment from p3 is now
too short, so you get the error you see.

The second example works because the lifetime used by p2 does not extend
after the println! in the inner block, so p3 can satisfy that lifetime.

#+begin_src rust
fn main() {
    struct Foo<'a, T> {
        a: &'a mut T,
    }

    let p1 = 1;
    let mut p2 = &p1;
    {
        let p3 = 2;
        let mut p4 = &p3;
        let mut f = Foo {
            a: &mut p4,
        };
        f.a = &mut p2;
        println!("{}", f.a);
    }
    // println!("{}", p2);
}
#+end_src

** variable invariant might be move out of scope, and free the memory.
:PROPERTIES:
:CUSTOM_ID: variable-invariant-might-be-move-out-of-scope-and-free-the-memory.
:END:


** 定义
#+begin_quote
假设1 C<T>是一个泛型类或接口, T是类型参数.

假设2 类型Dog是Animal的子类型.

定义1 Covariance/Covariant译作协变:
如果C<Dog>是C<Animal>的子类型, 那么C<T>对T协变.

定义2 Contravariance/Contravariant译作逆变:
如果C<Animal>是C<Dog>的子类型, 那么C<T>对T逆变.

定义3 Invariance/Invariant译作不变, 或译作抗变:
C<T>对T既不是协变也不是逆变, 那么C<T>对T不变.
#+end_quote

copy from [[https://rustcc.cn/article?id=698f0ff0-c96d-4686-89d4-af71f5656051][代码写明 Rust 中的泛型型变]]