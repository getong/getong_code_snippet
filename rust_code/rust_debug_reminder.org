* rust debug reminder

** duplicate customize self define type
error message

#+begin_src rust
65 | #[derive(NetworkBehaviour)]

   |          |
   |          expected 1 generic argument
   |          help: remove this generic argument
   |
note: type alias defined here, with 1 generic parameter: `T`
  --> /Users/gerald/.rustup/toolchains/nightly-x86_64-apple-darwin/lib/rustlib/src/rust/library/std/src/io/error.rs:54:10
   |
54 | pub type Result<T> = result::Result<T, Error>;
   |          ^^^^^^ -
   = note: this error originates in the derive macro `NetworkBehaviour` (in Nightly builds, run with -Z macro-backtrace for more info)
#+end_src


the self define type:

#+begin_src rust
type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync + 'static>>;
#+end_src

This is because Result<T, E> is auto import in Rust Edition 2021.
The solution is :
#+begin_src rust
type RecipeResult<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync + 'static>>;
#+end_src

** 'static parameter variable

#+begin_src rust
pub fn send(&mut self, reader: impl Read + 'static) -> Response
#+end_src

#+begin_quote
The distinction between owned and non-owned "objects" becomes a bit more complicated when you consider types like Vec<&u8>. The vector is owned but it contains references which borrow some other data. Similar to this are e.g. structs that contain references. The bound T: 'static basically means that T is a type that does not contain any non-'static references, even nested. (Static references like e.g. &'static str are allowed.)

One of the most popular cases of a T: 'static bound is std::thread::spawn 8. The reason there is that the closure and its return value need to be sent between threads, escaping their call-stack which is why they cannot contain any non-'static references since these could become invalidated in the other thread in the mean-time.

This is a good detailed explanation. A more pithy explanation is:
If a type is : 'static, it's possible for it to live for the rest of the program's duration.

This includes owned objects. A Vec<f64> can live for the rest of the program's duration. If you own that vec, you know it will live for as long as you do, up until the end of the program.
Since a static variable will live for the rest of the program's duration no matter what, it fits the above statement.

Note that the signature does not imply that reader is an owned object, with or without the 'static bound.
#+end_quote

copy from [[https://users.rust-lang.org/t/static-lifetime-with-owned-object/50637][â€˜static lifetime with owned object?]]

** use await with impl<futur>

not work:
#+begin_src rust
let (tx, mut rx) = tokio::sync::mpsc::channel(64);
send_channel.send(1);
#+end_src

change with await:
#+begin_src rust
let (tx, mut rx) = tokio::sync::mpsc::channel(64);
send_channel.send(1).await;
#+end_src

** Arc<Mutex<T>> in loop

#+begin_src rust
use std::sync::Arc;
use tokio::sync::Mutex;

#[tokio::main]
async fn main() {
  let data1 = Arc::new(Mutex::new(0));
  let data2 = data1.clone();
  loop {
    tokio::spawn(async move {
      let mut lock = data2.lock().await;
      *lock += 1;
    });
  }
}
#+end_src

It should be changed with:

#+begin_src rust
use std::sync::Arc;
use tokio::sync::Mutex;

#[tokio::main]
async fn main() {
  let data1 = Arc::new(Mutex::new(0));
  let data2 = data1.clone();
  loop {
    let data3 = data2.clone();
    tokio::spawn(async move {
      let mut lock = data3.lock().await;
      *lock += 1;
    });
  }
}
#+end_src

** Arc<Mutex<T>> in stream

#+begin_src rust
let num = Arc::new(Mutex::new(0));
  let num_clone = num.clone();

  let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), 12345);
  let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
  listener.config_mut().max_frame_length(usize::MAX);
  tokio::spawn(async move {
    listener
      // Ignore accept errors.
      .filter_map(|r| future::ready(r.ok()))
      .map(server::BaseChannel::with_defaults)
      // Limit channels to 1 per IP.
      .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
      // serve is generated by the service attribute. It takes as input any type implementing
      // the generated World trait.
      .map(|channel| {
        let server = Api {
          num: num_clone,
        };
        channel.execute(server.serve())
      })
      // Max 10 channels.
      .buffer_unordered(10)
      .for_each(|_| async {})
      .await
  });
#+end_src

it should be changed as:

#+begin_src rust
let num = Arc::new(Mutex::new(0));
  let num_clone = num.clone();

  let server_addr = (IpAddr::V4(Ipv4Addr::LOCALHOST), 12345);
  let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
  listener.config_mut().max_frame_length(usize::MAX);
  tokio::spawn(async move {
    listener
      // Ignore accept errors.
      .filter_map(|r| future::ready(r.ok()))
      .map(server::BaseChannel::with_defaults)
      // Limit channels to 1 per IP.
      .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
      // serve is generated by the service attribute. It takes as input any type implementing
      // the generated World trait.
      .map(|channel| {
        let server = Api {
          num: num_clone.clone(),
        };
        channel.execute(server.serve())
      })
      // Max 10 channels.
      .buffer_unordered(10)
      .for_each(|_| async {})
      .await
  });
#+end_src