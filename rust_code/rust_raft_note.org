* rust raft note
:PROPERTIES:
:CUSTOM_ID: rust-raft-note
:END:
[[https://github.com/tikv/raft-rs][raft-rs]]
[[https://www.hyperledger.org/blog/2019/01/11/floating-the-sawtooth-raft-implementing-a-consensus-algorithm-in-rust][Floating the Sawtooth Raft: Implementing a Consensus Algorithm in Rust]]
[[https://github.com/hyperledger/sawtooth-raft][sawtooth-raft]]
[[https://github.com/async-raft/async-raft][async-raft]]
[[https://blog.openacid.com/algo/abstract-paxos/][将 paxos 和 raft 统一到一个协议下: abstract-paxos]]
[[https://github.com/maemual/raft-zh_cn][raft-zh_cn]]
[[https://www.cnblogs.com/databend/p/16544634.html][OpenRaft 在交易撮合引擎中的应用]]

** openraft import trait
:PROPERTIES:
:CUSTOM_ID: openraft-import-trait
:END:
AppData

#+begin_src rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ExampleRequest {/* fields */}
impl AppData for ExampleRequest {}
#+end_src

AppDataResponse

#+begin_src rust
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ExampleResponse(Result<Option<String>, ClientError>);
impl AppDataResponse for ExampleResponse {}
#+end_src

RaftStorage

#+begin_src rust
pub trait RaftStorage<D, R>: Send + Sync + 'static
where
    D: AppData,
    R: AppDataResponse,
{
    type SnapshotData: AsyncRead + AsyncWrite + AsyncSeek + Send + Sync + Unpin + 'static;

// ...
}
#+end_src

RaftNetwork

#+begin_src rust
pub trait RaftNetwork<D>: Send + Sync + 'static
where
    D: AppData,
{
    fn send_append_entries<'life0, 'async_trait>(
        &'life0 self,
        target: NodeId,
        rpc: AppendEntriesRequest<D>
    ) -> Pin<Box<dyn Future<Output = Result<AppendEntriesResponse>> + Send + 'async_trait>>
    where
        'life0: 'async_trait,
        Self: 'async_trait;
    fn send_install_snapshot<'life0, 'async_trait>(
        &'life0 self,
        target: NodeId,
        rpc: InstallSnapshotRequest
    ) -> Pin<Box<dyn Future<Output = Result<InstallSnapshotResponse>> + Send + 'async_trait>>
    where
        'life0: 'async_trait,
        Self: 'async_trait;
    fn send_vote<'life0, 'async_trait>(
        &'life0 self,
        target: NodeId,
        rpc: VoteRequest
    ) -> Pin<Box<dyn Future<Output = Result<VoteResponse>> + Send + 'async_trait>>
    where
        'life0: 'async_trait,
        Self: 'async_trait;
}
#+end_src

copy from [[https://datafuselabs.github.io/openraft/getting-started.html][Getting Started]]

** Raft
:PROPERTIES:
:CUSTOM_ID: raft
:END:
#+begin_src rust
pub fn new(
    id: NodeId,
    config: Arc<Config>,
    network: Arc<N>,
    storage: Arc<S>
) -> Self

pub async fn vote(&self, rpc: VoteRequest) -> Result<VoteResponse, RaftError>

pub async fn current_leader(&self) -> Option<NodeId>
#+end_src

copy from [[https://docs.rs/openraft/latest/openraft/raft/struct.Raft.html][Struct openraft::raft::Raft]]


** openraft TypeConfig

#+begin_src rust
openraft::declare_raft_types!(
    /// Declare the type configuration for example K/V store.
    pub TypeConfig:
        D = Request,
        R = Response,
        // In this example, snapshot is just a copy of the state machine.
        // And it can be any type.
        SnapshotData = StateMachineData,
);
#+end_src

expand macro

#+begin_src rust
#[doc = r" Declare the type configuration for example K/V store."]
#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "serde", derive(serde::Deserialize, serde::Serialize))]
pub struct TypeConfig {}

impl $crate::RaftTypeConfig for TypeConfig {
  type D = Request;
  type R = Response;
  type SnapshotData = StateMachineData;
  type NodeId = u64;
  type Node = $crate::impls::BasicNode;
  type Entry = $crate::impls::Entry<Self>;
  type Responder = $crate::impls::OneshotResponder<Self>;
  type AsyncRuntime = $crate::impls::TokioRuntime;
}
#+end_src

** request and response

#+begin_src rust
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum Request {
  Set { key: String, value: String },
}

impl Request {
  pub fn set(key: impl ToString, value: impl ToString) -> Self {
    Self::Set {
      key: key.to_string(),
      value: value.to_string(),
    }
  }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Response {
  pub value: Option<String>,
}

#[derive(Debug)]
pub struct StoredSnapshot {
  pub meta: SnapshotMeta<TypeConfig>,

  /// The data of the state machine at the time of this snapshot.
  pub data: Box<SnapshotData>,
}

/// Data contained in the Raft state machine. Note that we are using `serde` to serialize the
/// `data`, which has a implementation to be serialized. Note that for this test we set both the key
/// and value as String, but you could set any type of value that has the serialization impl.
#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct StateMachineData {
  pub last_applied: Option<LogId<NodeId>>,

  pub last_membership: StoredMembership<TypeConfig>,

  /// Application data.
  pub data: BTreeMap<String, String>,
}

/// Defines a state machine for the Raft cluster. This state machine represents a copy of the
/// data for this node. Additionally, it is responsible for storing the last snapshot of the data.
#[derive(Debug, Default)]
pub struct StateMachineStore {
  /// The Raft state machine.
  pub state_machine: Mutex<StateMachineData>,

  snapshot_idx: Mutex<u64>,

  /// The last received snapshot.
  current_snapshot: Mutex<Option<StoredSnapshot>>,
}

impl RaftStateMachine<TypeConfig> for Arc<StateMachineStore> {
  type SnapshotBuilder = Self;

  async fn applied_state(
    &mut self,
  ) -> Result<(Option<LogId<NodeId>>, StoredMembership<TypeConfig>), StorageError<TypeConfig>> {
    let state_machine = self.state_machine.lock().unwrap();
    Ok((
      state_machine.last_applied,
      state_machine.last_membership.clone(),
    ))
  }

  #[tracing::instrument(level = "trace", skip(self, entries))]
  async fn apply<I>(&mut self, entries: I) -> Result<Vec<Response>, StorageError<TypeConfig>>
  where
    I: IntoIterator<Item = Entry<TypeConfig>>,
  {
    let mut res = Vec::new(); //No `with_capacity`; do not know `len` of iterator

    let mut sm = self.state_machine.lock().unwrap();

    for entry in entries {
      tracing::debug!(%entry.log_id, "replicate to sm");

      sm.last_applied = Some(entry.log_id);

      match entry.payload {
        EntryPayload::Blank => res.push(Response { value: None }),
        EntryPayload::Normal(ref req) => match req {
          Request::Set { key, value, .. } => {
            sm.data.insert(key.clone(), value.clone());
            res.push(Response {
              value: Some(value.clone()),
            })
          }
        },
        EntryPayload::Membership(ref mem) => {
          sm.last_membership = StoredMembership::new(Some(entry.log_id), mem.clone());
          res.push(Response { value: None })
        }
      };
    }
    Ok(res)
  }

  #[tracing::instrument(level = "trace", skip(self))]
  async fn begin_receiving_snapshot(
    &mut self,
  ) -> Result<Box<SnapshotDataOf<TypeConfig>>, StorageError<TypeConfig>> {
    Ok(Box::default())
  }

  #[tracing::instrument(level = "trace", skip(self, snapshot))]
  async fn install_snapshot(
    &mut self,
    meta: &SnapshotMeta<TypeConfig>,
    snapshot: Box<SnapshotDataOf<TypeConfig>>,
  ) -> Result<(), StorageError<TypeConfig>> {
    tracing::info!("install snapshot");

    let new_snapshot = StoredSnapshot {
      meta: meta.clone(),
      data: snapshot,
    };

    // Update the state machine.
    {
      let updated_state_machine: StateMachineData = *new_snapshot.data.clone();
      let mut state_machine = self.state_machine.lock().unwrap();
      ,*state_machine = updated_state_machine;
    }

    // Update current snapshot.
    let mut current_snapshot = self.current_snapshot.lock().unwrap();
    ,*current_snapshot = Some(new_snapshot);
    Ok(())
  }

  #[tracing::instrument(level = "trace", skip(self))]
  async fn get_current_snapshot(
    &mut self,
  ) -> Result<Option<Snapshot<TypeConfig>>, StorageError<TypeConfig>> {
    match &*self.current_snapshot.lock().unwrap() {
      Some(snapshot) => {
        let data = snapshot.data.clone();
        Ok(Some(Snapshot {
          meta: snapshot.meta.clone(),
          snapshot: data,
        }))
      }
      None => Ok(None),
    }
  }

  async fn get_snapshot_builder(&mut self) -> Self::SnapshotBuilder {
    self.clone()
  }
}

#+end_src

client send request
#+begin_src rust
let resp = raft1
  .client_write(Request::set("foo1", "bar1"))
  .await
  .unwrap();
#+end_src

** network

** raft data

** statemachine