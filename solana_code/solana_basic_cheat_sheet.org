#+TITLE: Solana Basic Cheat Sheet
#+DESCRIPTION: Comprehensive Solana development cheat sheet covering accounts, PDAs, programs, and CPIs

* Accounts

Accounts are where data is stored on the Solana blockchain.

** Key Points

- Accounts are used to store data
- A unique address identifies each account
- Each account has a 10MB (10 MegaBytes) max size
- Accounts size are fixed at creation time but can be adjusted using =realloc=
- Rent pays for account data storage
- The System Program owns the account by default

** Types of Accounts

There are two types of accounts on the Solana blockchain: executable and non-executable. Programs are executable accounts and store the immutable code of a program. The code of a program is first written in Rust or C/C++ and then compiled into byte code via the LLVM compiler infrastructure.

Data storage and token balances are stored in non-executable accounts as their data can be changed. To control who can change this data, non-executable accounts have an owner program address assigned to them. Other programs can read the data of another account, but if they tried to modify that data, the transaction would fail.

- *Program Account* — These accounts store executable code and the equivalent of Ethereum smart contracts
- *Storage Account* — These accounts store the data connected to programs
- *Token Account* — These accounts track an account balance of tokens and allow for transferring or receiving tokens between accounts

** Program Derived Addresses (PDAs)

There is an additional type of program-owned accounts — program-derived accounts, which are used to store data for a specific program. They obey the rules of the non-executable accounts, so they have owners, but they don't have the corresponding keypair, and only the =program_id= for which PDA was created can sign transactions to modify its data. That is very useful when you need storage that can only be modifiable by your program.

** Associated Token Accounts (ATAs)

In Solana, there is only one Token Program, which handles the creation of new tokens that are not actually executable unlike many other chains, and just storage with token metadata. So one of the most important examples of PDA is a so-called associated token account ATA. Such accounts are used for storing user's the balance of concrete SPL-token (token mint) for the concrete user. In other words, the ATA for a given wallet address is simply a program-derived account consisting of the wallet address itself and the token mint.

** Rent

Unfortunately, storing all this data into separate accounts is not free and comes with some costs. Luckily for developers, these costs, called Rent, are paid in lamports.

#+BEGIN_QUOTE
*RENT*

Accounts on Solana may have owner-controlled state (Account::data) that's separate from the account's balance (Account::lamports). Since validators on the network need to maintain a working copy of this state in memory, the network charges a time-and-space based fee for this resource consumption, also known as Rent.
#+END_QUOTE

Lamports are fractions of Solana's token (SOL). It can use them to make micropayments on the Solana blockchain. The amount of data it stores in its account determines its rent fee. The larger amount of data stored, the higher the rent fee.

Rent is paid during two different timings: when referenced by a transaction or once an epoch.

Rent fees are collected at the end of every epoch of the Solana blockchain. An epoch is the time that the leading validator is still valid to produce blocks of transactions. At the time of writing, an epoch lasts about two days. If its account balance is zero and it cannot pay rent, the blockchain will remove its account.

An account can become rent-exempted by holding at least two years worth of rent in its token balance. An easy way to estimate rent costs is by using the =solana rent= command via the Solana CLI. By providing your account's size (in bytes), you will see the rent per byte, per epoch, and the minimum amount for the account to be rent-exempted.

Rent can be retrieved by closing the account and sending the lamports back to the wallet.

** How to Create an Account

To create an account on Solana, a key pair (public and private) must be generated by a client. Then, the client uses the =SystemProgram::CreateAccount= call to register the public key and allocate the data storage size needed to be set for this account. Currently, this size can not be changed later, and the size limit is 10 MB. If more size is required, a program can copy the data from one account to another with a larger capacity.

When creating an account, an owner needs to be assigned to the account. Only the owner of the account can modify the data that is stored within the account. The default owner after an account is made is called the "System Program". The System Program is a native Solana program responsible for creating accounts, allocating data on accounts, and assigning ownership of accounts to the connected programs.

#+BEGIN_SRC rust
use solana_client::rpc_client::RpcClient;
use solana_program::system_instruction;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::native_token::LAMPORTS_PER_SOL;
use solana_sdk::signature::{Keypair, Signer};

fn main() {
    // Create an HTTP RpcClient with specified "confirmed" commitment level
    // "confirmed" - the node will query the most recent block that has been
    // voted on by supermajority of the cluster.
    let rpc_url = String::from("https://api.devnet.solana.com");
    let rpc_client = RpcClient::new_with_commitment(rpc_url,
        CommitmentConfig::confirmed());

    // Generate fee payer and new account key pairs
    let fee_payer = Keypair::new();
    let new_account = Keypair::new();

    // Request an airdrop for the fee payer and wait for the transaction to be confirmed
    let request_airdrop_tx_signature = rpc_client
        .request_airdrop(&fee_payer.pubkey(), LAMPORTS_PER_SOL)
        .unwrap();

    loop {
        if let Ok(confirmed) =
            rpc_client.confirm_transaction(&request_airdrop_tx_signature) {
            if confirmed {
                break;
            }
        }
    }

    // Specify account data length
    let space = 0;

    // Get minimum balance required to make an account with specified data
    // length rent exempt
    let rent_exemption_amount = rpc_client
        .get_minimum_balance_for_rent_exemption(space)
        .unwrap();

    // Create instruction to create an account
    let create_account_ix = system_instruction::create_account(
        &fee_payer.pubkey(),
        &new_account.pubkey(),
        rent_exemption_amount,
        space as u64,
        &fee_payer.pubkey(),
    );

    // Get recent blockhash
    let recent_blockhash = rpc_client.get_latest_blockhash().unwrap();

    // Create transaction to create an account
    let create_account_tx =
        solana_sdk::transaction::Transaction::new_signed_with_payer(
            &[create_account_ix],
            Some(&fee_payer.pubkey()),
            &[&fee_payer, &new_account],
            recent_blockhash,
        );

    // Submit a transaction to create an account and wait for confirmation
    let create_account_tx_signature = rpc_client
        .send_and_confirm_transaction(&create_account_tx)
        .unwrap();

    // Print transaction signature and account address
    println!("Transaction signature: {create_account_tx_signature}");
    println!("New account {} created successfully", new_account.pubkey());
}
#+END_SRC

** How to Create an Account with Seed

To create an account with seed, a client needs to generate a base key pair (public and private). Then, the derived public key needs to be generated from the specified seed and program id. Next, the client uses the =SystemProgram::CreateAccountWithSeed= call to register the derived public key and allocate the data storage size needed to be set for this account.

#+BEGIN_SRC rust
use solana_client::rpc_client::RpcClient;
use solana_program::pubkey::Pubkey;
use solana_program::system_instruction;
use solana_sdk::commitment_config::CommitmentConfig;
use solana_sdk::native_token::LAMPORTS_PER_SOL;
use solana_sdk::signature::{Keypair, Signer};

fn main() {
    // Create an HTTP RpcClient with specified "confirmed" commitment level
    let rpc_url = String::from("https://api.devnet.solana.com");
    let rpc_client = RpcClient::new_with_commitment(rpc_url,
        CommitmentConfig::confirmed());

    // Generate fee payer and base key pairs
    let fee_payer = Keypair::new();
    let base = Keypair::new();

    // Request an airdrop for the fee payer and wait for the transaction to be confirmed
    let request_airdrop_tx_signature = rpc_client
        .request_airdrop(&fee_payer.pubkey(), LAMPORTS_PER_SOL)
        .unwrap();

    loop {
        if let Ok(confirmed) =
            rpc_client.confirm_transaction(&request_airdrop_tx_signature) {
            if confirmed {
                break;
            }
        }
    }

    // Specify seed
    let seed = "seed123";

    // Get system program id
    let program_id = solana_program::system_program::id();

    // Generate derived public key
    let derived_pubkey = Pubkey::create_with_seed(&base.pubkey(), seed,
        &program_id).unwrap();

    // Specify account data length and number of lamports
    let space = 0;
    let lamports = LAMPORTS_PER_SOL / 10;

    // Create instruction to create an account with seed
    let create_account_with_seed_ix =
        system_instruction::create_account_with_seed(
            &fee_payer.pubkey(),
            &derived_pubkey,
            &base.pubkey(),
            seed,
            lamports,
            space as u64,
            &program_id,
        );

    // Get recent blockhash
    let recent_blockhash = rpc_client.get_latest_blockhash().unwrap();

    // Create transaction to create an account with seed
    let create_account_with_seed_tx =
        solana_sdk::transaction::Transaction::new_signed_with_payer(
            &[create_account_with_seed_ix],
            Some(&fee_payer.pubkey()),
            &[&fee_payer, &base],
            recent_blockhash,
        );

    // Submit a transaction to create an account with seed and wait for confirmation
    let create_account_with_seed_tx_signature = rpc_client
        .send_and_confirm_transaction(&create_account_with_seed_tx)
        .unwrap();

    // Print transaction signature and account address
    println!("Transaction signature: {create_account_with_seed_tx_signature}");
    println!("New account {} created with seed successfully", derived_pubkey);
}
#+END_SRC

** How to Close an Account

To close an account on Solana (erase all stored data), all stored SOLs must be removed.

#+BEGIN_SRC rust
use solana_program::{
    account_info::next_account_info, account_info::AccountInfo, entrypoint,
    entrypoint::ProgramResult, pubkey::Pubkey,
};

entrypoint!(process_instruction);

fn process_instruction(
    _program_id: &Pubkey,
    accounts: &[AccountInfo],
    _instruction_data: &[u8],
) -> ProgramResult {
    let account_info_iter = &mut accounts.iter();

    // Get source and destination accounts info
    let source_account_info = next_account_info(account_info_iter)?;
    let dest_account_info = next_account_info(account_info_iter)?;

    // Return lamports back to the destination account
    let dest_starting_lamports = dest_account_info.lamports();
    **dest_account_info.lamports.borrow_mut() = dest_starting_lamports
        .checked_add(source_account_info.lamports())
        .unwrap();
    **source_account_info.lamports.borrow_mut() = 0;

    // Remove source account data
    let mut source_data = source_account_info.data.borrow_mut();
    source_data.fill(0);

    Ok(())
}
#+END_SRC

** On Chain Account Data

Each account element is a metadata set, so the protocol can easily understand the account's type and additional information. Metadata consists of:

- *lamports* — the account's SOL balance, denominated in lamports, where 1 SOL = 10⁹ lamports
- *owner* — this is the address of the program that owns the account
- *executable* — a boolean variable that indicates if the account contains executable code
- *data* — the raw data byte array, stored in the account, be it storage variables or executable code
- *rent_epoch* — indicates the next epoch at which the account will owe rent

* Signer & Owner

** Signers

Each transaction explicitly lists all account public keys referenced by the transaction's instructions. A subset of those public keys is each accompanied by a transaction signature. Those signatures signal on chain programs that the account holder has authorized the transaction. Typically, the program uses the authorization to permit debiting the account or modifying its data.

Transactions include one or more digital signatures each corresponding to an account address referenced by the transaction.

Each of these addresses must be the public key of an ed25519 keypair, and the signature signifies that the holder of the matching private key signed, and thus, "authorized" the transaction. In this case, the account is referred to as a signer. Whether an account is a signer or not is communicated to the program as part of the account's metadata. Programs can then use that information to make authority decisions.

** Ownership and Assignment to Programs

In Solana, the person who owns the private key of the account is called the authority. Authority could grant Ownership over an account.

📎 *Owner* means a program that can modify the data of an account. Every account in Solana has an owner. A created account is initialized to be owned by a built-in program called the System Program and is called a system account. The runtime grants the program write access to the account if its id matches the owner. For the case of the System Program, the runtime allows clients to transfer lamports and importantly assign account ownership, meaning changing the owner to a different program id. If an account is not owned by a program, the program is only permitted to read its data and credit the account.

There are a few important ownership rules:

The Solana security model enforces that an account's data can only be modified by the account's Owner program. This allows the program to trust that the data is passed to them via accounts they own. The runtime enforces this by rejecting any transaction containing a program that attempts to write to an account it does not own.

* Program Derived Addresses (PDAs)

** Overview

The Solana account has limitations of the account size of 10Mb; sooner or later, you will hit that limit with user data. To resolve the problem, solana-sdk provides a way to store user data on a small per-user-generated account called a program-derived account (PDA). For simplicity, let's consider it as an account identifiable by a string with the same format as a Pubkey but doesn't have a corresponding private key. In short, PDAs are account keys that only the program (program_id) has the authority to sign.

** Key Points

- PDAs are 32 byte strings that look like public keys, but don't have corresponding private keys
- =findProgramAddress= will deterministically derive a PDA from a programId and seeds (collection of bytes)
- A bump (one byte) is used to push a potential PDA off the ed25519 elliptic curve
- Programs can sign for their PDAs by providing the seeds and bump to =invoke_signed=
- A PDA can only be signed by the program from which it was derived
- In addition to allowing for programs to sign for different instructions, PDAs also provide a hashmap-like interface for indexing accounts

** Good Practices

You may follow the next pieces of advice for working with PDA:

- Always use PDA when you need to store user data instead of storing it on program storage
- Verify the given PDA address by regenerating it with =find_program_address=. If your program requires using as little gas as possible, you may keep =find_program_address= on the client side and only verify that the account is not yet created or initialized
- Use all related accounts to PDA in a seed for =find_program_address= and use an enum for seed generation to avoid collision between seeds

** How to Create a PDA Account

📌 *Note:* PDA accounts can only be created on the program. The address can be generated client side.

To understand the concept behind PDAs, it may be helpful to consider that PDAs are not technically created, but found. PDAs are generated from a combination of seeds and a program id. This combination of seeds and program id is then run through a sha256 hash function to see whether or not they generate a public key that lies on the ed25519 elliptic curve.

=find_program_address= deterministically derives a PDA from a =program_id= and seeds (collection of bytes).

When a PDA is generated, =findProgramAddress= will return both the address and the bump used to kick the address off of the elliptic curve. Armed with this bump, a program can then sign for any instruction that requires its PDA.

#+BEGIN_SRC rust
// A pda is a public key of an account
// A bump (one byte) is used to push a potential PDA off the ed25519 elliptic curve
let (pda, bump_seed) = Pubkey::find_program_address(&[b"random-seed"], &program_id);
#+END_SRC

Creating a PDA essentially means to initialize the address with space and set the state to it. A normal keypair account can be created outside of our program and then fed to initialize its state. Unfortunately, for PDAs, it has been created on chain, due to the nature of not being able to sign on behalf of itself. Hence we use =invoke_signed= to pass the seeds of the PDA, along with the funding account's signature which results in account creation of a PDA.

This function expects 3 parameters:

- *instruction* — instruction to invoke
- *account_infos* — accounts required by instruction, where one is a pda required as signer
- *signers_seeds* — seeds to derive pda

#+BEGIN_SRC rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    pubkey::Pubkey,
    system_instruction,
    system_program,
};

entrypoint!(process_instruction);

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let account_info_iter = &mut accounts.iter();
    let payer = next_account_info(account_info_iter)?;
    let vault_pda = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;

    assert!(payer.is_writable);
    assert!(payer.is_signer);
    assert!(vault_pda.is_writable);
    assert_eq!(vault_pda.owner, &system_program::ID);
    assert!(system_program::check_id(system_program.key));

    let vault_bump_seed = instruction_data[0];
    let vault_seeds = &[b"vault", payer.key.as_ref(), &[vault_bump_seed]];
    let expected_vault_pda = Pubkey::create_program_address(vault_seeds, program_id)?;
    assert_eq!(vault_pda.key, &expected_vault_pda);

    let lamports = 10000000;
    let vault_size = 16;

    invoke_signed(
        &system_instruction::create_account(
            &payer.key,
            &vault_pda.key,
            lamports,
            vault_size,
            &program_id,
        ),
        &[
            payer.clone(),
            vault_pda.clone(),
        ],
        &[
            &[
                b"vault",
                payer.key.as_ref(),
                &[vault_bump_seed],
            ],
        ]
    )?;

    Ok(())
}
#+END_SRC

* Programs

** Definition

🤓 Solana Programs, often called "smart contracts" on other blockchains, are the executable code that interprets the instructions sent inside of each transaction on the blockchain. They can be deployed directly into the network's core as Native Programs or published by anyone as On Chain Programs. Programs are the core building blocks of the network and handle everything from sending tokens between wallets to accepting votes of DAOs, to tracking ownership of NFTs.

Both types of programs run on top of the Sealevel runtime, which is Solana's parallel processing model that helps to enable the high transaction speeds of the blockchain.

** Key Points

📍 Key points:

- Programs are essentially a special type of Accounts that is marked as "executable"
- Programs can own other Accounts
- Programs can only change the data or debit accounts they own
- Any program can read or credit another account
- Programs are considered stateless since the primary data stored in a program account is the compiled SBF code
- Programs can be upgraded by their owner
- Programs process instructions from both end users and other programs
- All programs are stateless: any data they interact with is stored in separate accounts that are passed in via instructions
- All programs are owned by the BPF Loader and executed by the Solana Runtime
- Developers most commonly write programs in Rust or C++, but can choose any language that targets the LLVM's BPF backend
- All programs have a single entry point where instruction processing takes place (i.e., =process_instruction=); parameters always include:
  - =program_id=: pubkey
  - =accounts=: array
  - =instruction_data=: byte array

** Types of Programs

The Solana blockchain has two types of programs:

- Native programs
- On chain programs

*** Native Programs

Native programs are those built directly into the core of the Solana blockchain. Similar to "on chain" programs in Solana, native programs can be called by any other program/user. However, they can only be upgraded as part of the core blockchain and cluster updates. These native program upgrades are controlled via the releases to the different clusters.

Examples of native programs include:

- *System Program*: Create new accounts, transfer tokens, and more
- *BPF Loader Program*: Deploys, upgrades, and executes programs on chain
- *Vote program*: Create and manage accounts that track validator voting state and rewards

*** On Chain Programs

These user-written programs, often called "smart contracts" on other blockchains, are deployed directly to the blockchain for anyone to interact with and execute. Hence the name "on chain".

In effect, "on chain programs" are any program that is not baked directly into the Solana cluster's core code (like the native programs discussed above).

And even though Solana Labs maintains a small subset of these on chain programs (collectively known as the Solana Program Library), anyone can create or publish one. These programs can also be updated directly on the blockchain by the respective program's Account owner.

*** Executable

When a Solana program is deployed onto the network, it's marked as "executable" by the BPF Loader Program. This allows the Solana runtime to efficiently and properly execute the compiled program code.

*** Upgradable

Unlike other blockchains, Solana programs can be upgraded after they are deployed to the network.

Native programs can only be upgraded as part of cluster updates when new software releases are made.

On chain programs can be upgraded by the account that is marked as the "Upgrade Authority", which is usually the Solana account/address that deployed the program to begin with.

** Writing Programs

Programs are most commonly developed with Rust or C++, but can be developed with any language that targets the LLVM's BPF backend. Recent initiatives by Neon Labs and Solang enable EVM compatibility and allow developers to write programs in Solidity.

Most Rust-based programs adhere to the following architecture:

- =lib.rs= — Registering modules
- =entrypoint.rs= — Entrypoint to the program
- =instruction.rs= — Program API, (de)serializing instruction data
- =processor.rs= — Program logic
- =state.rs= — Program objects, (de)serializing state
- =error.rs= — Program-specific errors

In fact, one =lib.rs= module is enough, but it's good practice to split the program into the modules listed above 🤓.

* Cross Program Invocations (CPIs)

** Definition

🤓 A Cross-Program Invocation (CPI) is a direct call from one program to another. Just as any client can call any program using the JSON RPC, any program can call any other program directly. The only requirement for invoking an instruction on another program from within your program is that you construct the instruction correctly. You can make CPIs to native programs, other programs you've created, and third-party programs.

** Key Points

📍 Key points:

- A Cross-Program Invocation (CPI) is a call from one program to another, targeting a specific instruction on the program being called
- CPIs allow the calling program to extend its signer privileges to the callee program
- Programs can execute CPIs using either =invoke= or =invoke_signed= within their instructions
- =invoke= is used when all required signatures are accessible prior to invocation, without the need for PDAs to act as signers
- =invoke_signed= is used when PDAs from the calling program are required as signers in the CPI
- After a CPI is made to another program, the callee program can make further CPIs to other programs, up to a maximum depth of 4

** How to Make a CPI

CPIs are made using the =invoke= or =invoke_signed= function from the solana_program crate. You use =invoke= to essentially pass through the original transaction signature that was passed into your program. You use =invoke_signed= to have your program "sign" for its PDAs.

The =invoke= function is used when making a CPI that does not require any PDAs to act as signers. When making CPIs, the Solana runtime extends the original signature passed into a program to the callee program.

=invoke= function expects 2 parameters:

- *instruction* — instruction to invoke
- *account_infos* — accounts required by instruction

#+BEGIN_SRC rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    msg,
    program::invoke,
    program_error::ProgramError,
    pubkey::Pubkey,
    rent::Rent,
    system_instruction::create_account,
    sysvar::Sysvar,
};

entrypoint!(process_instruction);

// Accounts required
/// 1. [signer, writable] Payer Account
/// 2. [signer, writable] General State Account
/// 3. [] System Program
pub fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();

    // Accounts required for token transfer
    // 1. Payer account for the state account creation
    let payer_account = next_account_info(accounts_iter)?;
    // 2. Token account we hold
    let general_state_account = next_account_info(accounts_iter)?;
    // 3. System Program
    let system_program = next_account_info(accounts_iter)?;

    // Account size in bytes
    // a. Getting the span of the first 8 bytes containing little endian integers
    // b. Getting the account span from the little endian integers
    // c. Converting the little endian integers to a u64 number
    let account_span = instruction_data
        .get(..8)
        .and_then(|slice| slice.try_into().ok())
        .map(u64::from_le_bytes)
        .ok_or(ProgramError::InvalidAccountData)?;

    let lamports_required = (Rent::get()?).minimum_balance(account_span as usize);

    // Creating a new TransactionInstruction
    let create_account_instruction = create_account(
        &payer_account.key,
        &general_state_account.key,
        lamports_required,
        account_span,
        program_id,
    );

    let required_accounts_for_create = [
        payer_account.clone(),
        general_state_account.clone(),
        system_program.clone(),
    ];

    // Passing the TransactionInstruction to send (with the issued program_id)
    invoke(&create_account_instruction, &required_accounts_for_create)?;

    msg!("Transfer successful");

    Ok(())
}
#+END_SRC

To make a CPI that requires a PDA as a signer, use the =invoke_signed= function and provide the necessary seeds to derive the required PDA of the calling program.

=invoke_signed= function expects 3 parameters:

- *instruction* — instruction to invoke
- *account_infos* — accounts required by instruction, where one is a pda required as signer
- *signers_seeds* — seeds to derive pda

While PDAs have no private keys of their own, they can still act as a signer in an instruction via a CPI. To verify that a PDA belongs to the calling program, the seeds used to generate the PDA required as a signer must be included in as =signers_seeds=.

The Solana runtime will internally call =create_program_address= using the seeds provided and the =program_id= of the calling program. The resulting PDA is then compared to the addresses supplied in the instruction. If there's a match, the PDA is considered a valid signer.

#+BEGIN_SRC rust
use solana_program::{
    account_info::{next_account_info, AccountInfo},
    entrypoint,
    entrypoint::ProgramResult,
    program::invoke_signed,
    pubkey::Pubkey,
    system_instruction,
    system_program,
};

entrypoint!(process_instruction);

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let account_info_iter = &mut accounts.iter();
    let payer = next_account_info(account_info_iter)?;
    let vault_pda = next_account_info(account_info_iter)?;
    let system_program = next_account_info(account_info_iter)?;

    assert!(payer.is_writable);
    assert!(payer.is_signer);
    assert!(vault_pda.is_writable);
    assert_eq!(vault_pda.owner, &system_program::ID);
    assert!(system_program::check_id(system_program.key));

    let vault_bump_seed = instruction_data[0];
    let vault_seeds = &[b"vault", payer.key.as_ref(), &[vault_bump_seed]];
    let expected_vault_pda = Pubkey::create_program_address(vault_seeds, program_id)?;
    assert_eq!(vault_pda.key, &expected_vault_pda);

    let lamports = 10000000;
    let vault_size = 16;

    invoke_signed(
        &system_instruction::create_account(
            &payer.key,
            &vault_pda.key,
            lamports,
            vault_size,
            &program_id,
        ),
        &[
            payer.clone(),
            vault_pda.clone(),
        ],
        &[
            &[
                b"vault",
                payer.key.as_ref(),
                &[vault_bump_seed],
            ],
        ]
    )?;

    Ok(())
}
#+END_SRC

** Instructions that Require Privileges

🧐 The runtime uses the privileges granted to the caller program to determine what privileges can be extended to the callee. Privileges in this context refer to signers and writable accounts. For example, suppose the instruction the caller is processing contains a signer or writable account. In that case, the caller can invoke an instruction containing that signer and/or writable account.

This privilege extension relies on the fact that programs are immutable, except during the special case of program upgrades.

E.g., In the case of the transfer token program, the runtime can safely treat the transaction's signature as a signature of a token instruction. When the runtime sees the token instruction references =alice_pubkey=, it looks up the key in an acme instruction to see if that key corresponds to a signed account. In this case, it does and thereby authorizes the token program to modify Alice's account.

** Reentrancy

Reentrancy is currently limited to direct self recursion, capped at a fixed depth. This restriction prevents situations where a program might invoke another from an intermediary state without the knowledge that it might later be called back into. Direct recursion gives the program full control of its state at the point that it gets called back.

* Useful Links

🔗 Useful links:

- [[https://spl.solana.com/][Solana Program Library]]
- [[https://solanacookbook.com/references/programs.html#how-to-change-account-size][Example of resizing an account using realloc]]
- [[https://llvm.org/][LLVM Project]]
- [[https://spl.solana.com/token][A Token program on the Solana blockchain]]
- [[https://spl.solana.com/associated-token-account][Associated Token Account Program]]
- [[https://explorer.solana.com/][Solana Explorer]]
- [[https://docs.solana.com/cli/usage#solana-rent][Documentation of using the solana-rent command]]
- [[https://docs.solana.com/developing/programming-model/calling-between-programs#program-signed-accounts][A couple of words about signing transactions with programs]]
- [[https://solanacookbook.com/guides/account-maps.html][Account Maps]]
- [[https://docs.rs/solana-program/latest/solana_program/pubkey/struct.Pubkey.html#method.find_program_address][More about seeds and PDAs]]
- [[https://medium.com/solana-labs/sealevel-parallel-processing-thousands-of-smart-contracts-d814b378192][What a Sealevel is]]
- [[https://docs.solana.com/developing/programming-model/runtime][Solana Runtime]]
- [[https://en.wikipedia.org/wiki/Berkeley_Packet_Filter][What a BPF and BPF Loader is]]
- [[https://docs.solana.com/developing/runtime-facilities/programs#bpf-loader][BPF Loader documentation]]
- [[https://docs.solana.com/cluster/overview][More about Clusters in Solana]]
- [[https://neon-labs.org/][Write programs in Solidity]]
- [[https://solang.readthedocs.io/en/latest/][Solang documentation]]
- [[https://ethereum.org/en/developers/docs/evm/][Ethereum Virtual Machine]]

---

*Source:* [[https://medium.com/@maicmi/solana-basic-cheat-sheet-cb32c732c26e][Solana Basic Cheat Sheet by maicmi]] (Medium Article)
